/*
* This file was automatically generated by EvoSuite
* Thu Feb 27 18:35:15 GMT 2020
*/

package com.google.escapevelocity;

import com.google.common.collect.*;
import com.google.escapevelocity.*;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.*;

import static org.evosuite.runtime.EvoAssertions.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.junit.Assert.*;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true)
public class ReferenceNode_ESTest extends ReferenceNode_ESTest_scaffolding {

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test00() throws Throwable {
        ReferenceNode.PlainReferenceNode referenceNode_PlainReferenceNode0 = new ReferenceNode.PlainReferenceNode((String) null, (-1654), (String) null);
        Class<Integer>[] classArray0 = (Class<Integer>[]) Array.newInstance(Class.class, 8);
        Class<Integer> class0 = Integer.class;
        ExpressionNode.NotExpressionNode expressionNode_NotExpressionNode0 = new ExpressionNode.NotExpressionNode(referenceNode_PlainReferenceNode0);
        ReferenceNode.IndexReferenceNode referenceNode_IndexReferenceNode0 = new ReferenceNode.IndexReferenceNode(referenceNode_PlainReferenceNode0, expressionNode_NotExpressionNode0);
        BoundType boundType0 = BoundType.CLOSED;
        ImmutableList<Object> immutableList0 = ImmutableList.of((Object) "Member ", (Object) class0, (Object) class0, (Object) "", (Object) referenceNode_IndexReferenceNode0, (Object) class0, (Object) "cEL#1)W}7#j%Yo", (Object) boundType0, (Object) referenceNode_IndexReferenceNode0);
        boolean boolean0 = ReferenceNode.MethodReferenceNode.compatibleArgs(classArray0, immutableList0);
        assertFalse(boolean0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test01() throws Throwable {
        ReferenceNode.PlainReferenceNode referenceNode_PlainReferenceNode0 = new ReferenceNode.PlainReferenceNode("`jT", 1, "~iCj-");
        ImmutableBiMap<String, String> immutableBiMap0 = ImmutableBiMap.of();
        ImmutableSortedMap<String, Macro> immutableSortedMap0 = ImmutableSortedMap.of();
        EvaluationContext.PlainEvaluationContext evaluationContext_PlainEvaluationContext0 = new EvaluationContext.PlainEvaluationContext(immutableBiMap0, immutableSortedMap0, (MethodFinder) null);
        boolean boolean0 = referenceNode_PlainReferenceNode0.isDefinedAndTrue(evaluationContext_PlainEvaluationContext0);
        assertFalse(boolean0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test02() throws Throwable {
        ReferenceNode.PlainReferenceNode referenceNode_PlainReferenceNode0 = new ReferenceNode.PlainReferenceNode("zi`-hp4ig&oAL7L+Y", 0, "zi`-hp4ig&oAL7L+Y");
        HashMap<String, BoundType> hashMap0 = new HashMap<String, BoundType>();
        MethodFinder methodFinder0 = new MethodFinder();
        BoundType boundType0 = BoundType.CLOSED;
        hashMap0.put("zi`-hp4ig&oAL7L+Y", boundType0);
        EvaluationContext.PlainEvaluationContext evaluationContext_PlainEvaluationContext0 = new EvaluationContext.PlainEvaluationContext(hashMap0, (ImmutableMap<String, Macro>) null, methodFinder0);
        Object object0 = referenceNode_PlainReferenceNode0.evaluate(evaluationContext_PlainEvaluationContext0);
        assertSame(object0, boundType0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test03() throws Throwable {
        ReferenceNode.PlainReferenceNode referenceNode_PlainReferenceNode0 = new ReferenceNode.PlainReferenceNode("com.google.common.collect.DiscreteDomain$IntegerDomain", 2557, "X+HUh]utnd~-O{Q");
        ImmutableSortedMap<String, String> immutableSortedMap0 = ImmutableSortedMap.of("", "");
        MethodFinder methodFinder0 = new MethodFinder();
        EvaluationContext.PlainEvaluationContext evaluationContext_PlainEvaluationContext0 = new EvaluationContext.PlainEvaluationContext(immutableSortedMap0, (ImmutableMap<String, Macro>) null, methodFinder0);
        // Undeclared exception!
        try {
            referenceNode_PlainReferenceNode0.evaluate(evaluationContext_PlainEvaluationContext0);
            fail("Expecting exception: RuntimeException");

        } catch (RuntimeException e) {
            //
            // In expression on line 2557 of com.google.common.collect.DiscreteDomain$IntegerDomain: Undefined reference $X+HUh]utnd~-O{Q
            //
            verifyException("com.google.escapevelocity.Node", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test04() throws Throwable {
        ReferenceNode.PlainReferenceNode referenceNode_PlainReferenceNode0 = new ReferenceNode.PlainReferenceNode("`jT", 1, "~iCj-");
        ImmutableBiMap<String, String> immutableBiMap0 = ImmutableBiMap.of();
        ImmutableSortedMap<String, Macro> immutableSortedMap0 = ImmutableSortedMap.of();
        EvaluationContext.PlainEvaluationContext evaluationContext_PlainEvaluationContext0 = new EvaluationContext.PlainEvaluationContext(immutableBiMap0, immutableSortedMap0, (MethodFinder) null);
        ReferenceNode.IndexReferenceNode referenceNode_IndexReferenceNode0 = new ReferenceNode.IndexReferenceNode(referenceNode_PlainReferenceNode0, referenceNode_PlainReferenceNode0);
        ReferenceNode.MemberReferenceNode referenceNode_MemberReferenceNode0 = new ReferenceNode.MemberReferenceNode(referenceNode_IndexReferenceNode0, "");
        ImmutableList<ExpressionNode> immutableList0 = ImmutableList.of((ExpressionNode) referenceNode_PlainReferenceNode0, (ExpressionNode) referenceNode_MemberReferenceNode0, (ExpressionNode) referenceNode_PlainReferenceNode0, (ExpressionNode) referenceNode_PlainReferenceNode0, (ExpressionNode) referenceNode_PlainReferenceNode0, (ExpressionNode) referenceNode_IndexReferenceNode0);
        ReferenceNode.MethodReferenceNode referenceNode_MethodReferenceNode0 = new ReferenceNode.MethodReferenceNode(referenceNode_PlainReferenceNode0, "`jT", immutableList0);
        // Undeclared exception!
        try {
            referenceNode_MethodReferenceNode0.evaluate(evaluationContext_PlainEvaluationContext0);
            fail("Expecting exception: RuntimeException");

        } catch (RuntimeException e) {
            //
            // In expression on line 1 of `jT: Undefined reference $~iCj-
            //
            verifyException("com.google.escapevelocity.Node", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o método primitiveTypeIsAssignmentCompatible() retorna valor igual ao esperado.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test05() throws Throwable {
        Class<String> class0 = String.class;
        boolean boolean0 = ReferenceNode.MethodReferenceNode.primitiveTypeIsAssignmentCompatible(class0, class0);
        assertTrue(boolean0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o método primitiveTypeIsAssignmentCompatible() retorna valor igual ao esperado.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test06() throws Throwable {
        Class<Object> class0 = Object.class;
        Class<BoundType> class1 = BoundType.class;
        boolean boolean0 = ReferenceNode.MethodReferenceNode.primitiveTypeIsAssignmentCompatible(class0, class1);
        assertFalse(boolean0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o método compatibleArgs() retorna valor igual ao esperado.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test07() throws Throwable {
        Class<Object>[] classArray0 = (Class<Object>[]) Array.newInstance(Class.class, 2);
        Class<Object> class0 = Object.class;
        classArray0[0] = class0;
        classArray0[1] = class0;
        ImmutableList<Object> immutableList0 = ImmutableList.copyOf((Object[]) classArray0);
        boolean boolean0 = ReferenceNode.MethodReferenceNode.compatibleArgs(classArray0, immutableList0);
        assertTrue(boolean0);
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o método compatibleArgs() retorna valor igual ao esperado.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test08() throws Throwable {
        Class<Macro>[] classArray0 = (Class<Macro>[]) Array.newInstance(Class.class, 2);
        Class<Macro> class0 = Macro.class;
        classArray0[0] = class0;
        ImmutableList<Object> immutableList0 = ImmutableList.of((Object) "FF4w*X<n'", (Object) class0);
        boolean boolean0 = ReferenceNode.MethodReferenceNode.compatibleArgs(classArray0, immutableList0);
        assertFalse(boolean0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o método compatibleArgs() retorna valor igual ao esperado.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test09() throws Throwable {
        Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 9);
        Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
        Vector<Object> vector0 = new Vector<Object>(6981);
        ImmutableList<Object> immutableList0 = ImmutableList.sortedCopyOf((Comparator<? super Object>) comparator0, (Iterable<?>) vector0);
        boolean boolean0 = ReferenceNode.MethodReferenceNode.compatibleArgs(classArray0, immutableList0);
        assertFalse(boolean0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test10() throws Throwable {
        ReferenceNode.PlainReferenceNode referenceNode_PlainReferenceNode0 = new ReferenceNode.PlainReferenceNode("{G tT*N7x`$=YhK?a%", (-16), "{G tT*N7x`$=YhK?a%");
        ReferenceNode.IndexReferenceNode referenceNode_IndexReferenceNode0 = new ReferenceNode.IndexReferenceNode(referenceNode_PlainReferenceNode0, referenceNode_PlainReferenceNode0);
        ImmutableMap<String, ExpressionNode> immutableMap0 = ImmutableMap.of("{G tT*N7x`$=YhK?a%", (ExpressionNode) referenceNode_PlainReferenceNode0);
        MethodFinder methodFinder0 = new MethodFinder();
        EvaluationContext.PlainEvaluationContext evaluationContext_PlainEvaluationContext0 = new EvaluationContext.PlainEvaluationContext(immutableMap0, (ImmutableMap<String, Macro>) null, methodFinder0);
        Macro.MacroEvaluationContext macro_MacroEvaluationContext0 = new Macro.MacroEvaluationContext(immutableMap0, evaluationContext_PlainEvaluationContext0);
        // Undeclared exception!
        try {
            referenceNode_IndexReferenceNode0.evaluate(macro_MacroEvaluationContext0);
            fail("Expecting exception: RuntimeException");

        } catch (RuntimeException e) {
            //
            // In expression on line -16 of {G tT*N7x`$=YhK?a%: No method get in com.google.escapevelocity.ReferenceNode$PlainReferenceNode
            //
            verifyException("com.google.escapevelocity.Node", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test11() throws Throwable {
        ReferenceNode.PlainReferenceNode referenceNode_PlainReferenceNode0 = new ReferenceNode.PlainReferenceNode("zi`-hp4ig&oAL7L+Y", 0, "zi`-hp4ig&oAL7L+Y");
        HashMap<String, BoundType> hashMap0 = new HashMap<String, BoundType>();
        MethodFinder methodFinder0 = new MethodFinder();
        BoundType boundType0 = BoundType.CLOSED;
        hashMap0.put("zi`-hp4ig&oAL7L+Y", boundType0);
        EvaluationContext.PlainEvaluationContext evaluationContext_PlainEvaluationContext0 = new EvaluationContext.PlainEvaluationContext(hashMap0, (ImmutableMap<String, Macro>) null, methodFinder0);
        boolean boolean0 = referenceNode_PlainReferenceNode0.isDefinedAndTrue(evaluationContext_PlainEvaluationContext0);
        assertTrue(boolean0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste é complexo de ser compreendido.
    *
    * Compreensivel: não
    *     - Tanto o comportamento do teste quanto suas instruções não são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test12() throws Throwable {
        ReferenceNode.PlainReferenceNode referenceNode_PlainReferenceNode0 = new ReferenceNode.PlainReferenceNode("=ELw", 1077, "");
        ReferenceNode.MemberReferenceNode referenceNode_MemberReferenceNode0 = new ReferenceNode.MemberReferenceNode(referenceNode_PlainReferenceNode0, "aG~WnvzrxC*:8`");
        ExpressionNode.NotExpressionNode expressionNode_NotExpressionNode0 = new ExpressionNode.NotExpressionNode(referenceNode_PlainReferenceNode0);
        ImmutableMap<String, ExpressionNode> immutableMap0 = ImmutableMap.of("", (ExpressionNode) referenceNode_PlainReferenceNode0, "~co", (ExpressionNode) expressionNode_NotExpressionNode0);
        Vector<Map.Entry<String, Macro>> vector0 = new Vector<Map.Entry<String, Macro>>();
        Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer());
        ImmutableSortedMap<String, Macro> immutableSortedMap0 = ImmutableSortedMap.copyOf((Iterable<? extends Map.Entry<? extends String, ? extends Macro>>) vector0, (Comparator<? super String>) comparator0);
        MethodFinder methodFinder0 = new MethodFinder();
        EvaluationContext.PlainEvaluationContext evaluationContext_PlainEvaluationContext0 = new EvaluationContext.PlainEvaluationContext(immutableMap0, immutableSortedMap0, methodFinder0);
        // Undeclared exception!
        try {
            referenceNode_MemberReferenceNode0.evaluate(evaluationContext_PlainEvaluationContext0);
            fail("Expecting exception: RuntimeException");

        } catch (RuntimeException e) {
            //
            // In expression on line 1077 of =ELw: Member aG~WnvzrxC*:8` does not correspond to a public getter of com.google.escapevelocity.ReferenceNode$PlainReferenceNode@1, a com.google.escapevelocity.ReferenceNode$PlainReferenceNode
            //
            verifyException("com.google.escapevelocity.Node", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o método invokeMethod() lança uma RuntimeException.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste quanto suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test13() throws Throwable {
        ReferenceNode.PlainReferenceNode referenceNode_PlainReferenceNode0 = new ReferenceNode.PlainReferenceNode((String) null, 1, "");
        Stack<Object> stack0 = new Stack<Object>();
        // Undeclared exception!
        try {
            referenceNode_PlainReferenceNode0.invokeMethod((Method) null, (Object) null, stack0);
            fail("Expecting exception: RuntimeException");

        } catch (RuntimeException e) {
            //
            // In expression on line 1: java.lang.NullPointerException
            //
            verifyException("com.google.escapevelocity.Node", e);
        }
    }
}
